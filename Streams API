# Streams in Java

Java Streams, introduced in Java 8, are a powerful abstraction for processing sequences of elements in a functional programming style. They provide a declarative way to work with collections and other data sources.

## What are Streams? 

A Stream is **not a data structure** but rather a pipeline for processing data. It represents a sequence of elements that can be processed sequentially or in parallel.  Streams don't store data; they convey elements from a source through a pipeline of operations.

## Key Characteristics

1. **No storage**: Streams don't store elements; they compute them on demand
2. **Functional in nature**: Stream operations produce results but don't modify the source
3. **Lazy evaluation**:  Intermediate operations are not executed until a terminal operation is invoked
4. **Possibly unbounded**: Streams can be infinite
5. **Consumable**: Stream elements can only be visited once; you need to create a new stream to revisit

## Stream Operations

### Intermediate Operations
These return a new stream and are always lazy (executed only when a terminal operation is called):

- **`filter(Predicate)`**: Filters elements based on a condition
- **`map(Function)`**: Transforms each element
- **`flatMap(Function)`**: Flattens nested structures
- **`distinct()`**: Removes duplicates
- **`sorted()`**: Sorts elements
- **`limit(n)`**: Limits to first n elements
- **`skip(n)`**: Skips first n elements
- **`peek(Consumer)`**: Performs an action without modifying the stream

### Terminal Operations
These produce a result or side effect and trigger stream processing:

- **`forEach(Consumer)`**: Performs an action for each element
- **`collect(Collector)`**: Converts stream to a collection
- **`reduce(BinaryOperator)`**: Reduces elements to a single value
- **`count()`**: Counts elements
- **`anyMatch/allMatch/noneMatch(Predicate)`**: Checks conditions
- **`findFirst/findAny()`**: Finds elements
- **`min/max(Comparator)`**: Finds minimum/maximum

## Examples

### Basic Example
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// Filter and collect
List<String> filtered = names.stream()
    .filter(name -> name.startsWith("A"))
    .collect(Collectors.toList());
// Result: ["Alice"]
```

### Mapping and Transformation
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> squared = numbers.stream()
    .map(n -> n * n)
    .collect(Collectors.toList());
// Result: [1, 4, 9, 16, 25]
```

### Filtering and Counting
```java
long count = numbers.stream()
    .filter(n -> n > 2)
    .count();
// Result: 3
```

### Reducing
```java
int sum = numbers.stream()
    .reduce(0, (a, b) -> a + b);
// Result: 15

// Or using method reference
int sum = numbers.stream()
    .reduce(0, Integer::sum);
```

### Complex Pipeline
```java
List<String> result = names.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());
// Result: ["ALICE", "CHARLIE", "DAVID"]
```

### Parallel Streams
```java
int sum = numbers.parallelStream()
    .filter(n -> n % 2 == 0)
    .mapToInt(Integer::intValue)
    .sum();
```

## Creating Streams

```java
// From collections
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();

// From arrays
String[] array = {"a", "b", "c"};
Stream<String> stream = Arrays.stream(array);

// Using Stream.of()
Stream<String> stream = Stream.of("a", "b", "c");

// Empty stream
Stream<String> empty = Stream.empty();

// Infinite streams
Stream<Integer> infinite = Stream.iterate(0, n -> n + 1);
Stream<Double> random = Stream.generate(Math::random);

// From files
Stream<String> lines = Files.lines(Paths.get("file.txt"));
```

## Best Practices

1. **Don't reuse streams**: Once consumed, create a new stream
2. **Avoid side effects**: Keep operations pure
3. **Use method references**: More readable than lambdas when appropriate
4. **Close resource streams**: Use try-with-resources for streams from files
5. **Consider parallel carefully**: Not always faster due to overhead
6. **Prefer specific primitive streams**: Use `IntStream`, `LongStream`, `DoubleStream` for better performance

## Common Collectors

```java
// To List
List<String> list = stream.collect(Collectors.toList());

// To Set
Set<String> set = stream.collect(Collectors.toSet());

// To Map
Map<Integer, String> map = stream.collect(
    Collectors.toMap(String::length, s -> s)
);

// Joining strings
String joined = stream.collect(Collectors.joining(", "));

// Grouping
Map<Integer, List<String>> grouped = stream.collect(
    Collectors.groupingBy(String:: length)
);

// Partitioning
Map<Boolean, List<Integer>> partitioned = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
```

Streams make Java code more concise, readable, and often more efficient, especially when dealing with large datasets or when parallel processing is beneficial. 
